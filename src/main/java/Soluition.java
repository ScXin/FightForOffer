/**
 * @author ScXin
 * @date 5/17/2019 9:50 AM
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 * <p>
 * 代码面试指南题解
 * 第五章
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 * <p>
 * 数组中良好个字符串的最小距离   难度：**
 * <p>
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 * <p>
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 */

/**
 * 代码面试指南题解
 */


/**第五章*/

/**
 * 删除多于字符得到字典顺序最小的字符串  难度：**
 */
//public class Solution {
//    public String removeDuplicateLetters(String a) {
//        char[] str = a.toCharArray();
//        int[] map = new int[26];
//
//        for (int i = 0; i < str.length; i++) {
//            map[str[i] - 'a']++;
//        }
//        char[] res = new char[26];
//        int index = 0;
//        int L = 0;
//        int R = 0;
//        while (R != str.length) {
//            if (map[str[R] - 'a'] == -1 || --map[str[R] - 'a'] > 0) {
//                R++;
//            } else {
//                int pick = -1;
//                for (int i = L; i <= R; i++) {
//                    if (map[str[i] - 'a'] != -1 && (pick == -1 || str[i] < str[pick])) {
//                        pick = i;
//                    }
//                }
//                res[index++] = str[pick];
//                for (int i = pick + 1; i <= R; i++) {
//                    if (map[str[i] - 'a'] != -1) {
//                        map[str[i] - 'a']++;
//                    }
//                }
//                map[str[pick] - 'a'] = -1;
//                L = pick + 1;
//                R = L;
//            }
//        }
//        return new String(res);
//    }
//}


/**
 * 数组中良好个字符串的最小距离   难度：**
 */
//public class Solution {
//    public static int minDistance(String[] strs, String str1, String str2) {
//        int s1 = -1;
//        int s2 = -1;
//        for (int i = 0; i < strs.length; i++) {
//            if (s1 == -1 && strs[i].equals(str1)) {
//                s1 = i;
//            }
//            if (s2 == -1 && strs[i].equals(str2)) {
//                s2 = i;
//            }
//        }
//        System.out.println("s1==" + s1 + "  s2==" + s2);
//        int minDis = Math.abs(s2 - s1);
//        if (s1 < s2) {
//            s1++;
//        } else {
//            s2++;
//        }
//
//        while ((s1 < strs.length && s2 < strs.length)) {
//            if (s1 < s2) {
//                if (strs[s1].equals(str1) && strs[s2].equals(str2)) {
//                    minDis = Math.min(minDis, Math.abs(s2 - s1));
//                    s1++;
//                    continue;
//                } else if (strs[s1].equals(str1)) {
//                    s2++;
//                    continue;
//                } else {
//                    s1++;
//                    continue;
//                }
//            }
//            if (s1 == s2) {
//                if (strs[s1].equals(str1)) {
//                    s2++;
//                    continue;
//                } else {
//                    s1++;
//                    continue;
//                }
//            }
//            if (s1 > s2) {
//                if (strs[s1].equals(str1) && strs[s2].equals(str2)) {
//                    minDis = Math.min(minDis, Math.abs(s2 - s1));
//                    s2++;
//                    continue;
//                } else if (strs[s1].equals(str1)) {
//                    s2++;
//                    continue;
//                } else {
//                    s1++;
//                    continue;
//                }
//            }
//        }
//        return minDis;
//    }
//
//    public static void main(String[] args) {
//        String[] arr = {"1", "3", "3", "3", "2", "1", "3", "4"};
//        System.out.println(minDistance(arr, "2", "4"));
//    }
//}
//
//public class Solution {
//    public static int[][] getDP(char[] str) {
//        int[][] dp = new int[str.length][str.length];
//        for (int j = 1; j < str.length; j++) {
//            dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
//            for (int i = j - 2; i >= 0; i--) {
//                if (str[i] == str[j]) {
//                    dp[i][j] = dp[i + 1][j - 1];
//                } else {
//                    dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
//                }
//            }
//        }
//        return dp;
//    }
//
//    public static String getPalindrome1(String str) {
//        if (str == null || str.length() < 2) {
//            return str;
//        }
//        char[] chas = str.toCharArray();
//        int[][] dp = getDP(chas);
//        char[] res = new char[dp[0][chas.length - 1] + chas.length];
//        int i = 0;
//        int j = chas.length - 1;
//        int resl = 0;
//        int resr = res.length-1;
//        while (i <= j) {
//            if (chas[i] == chas[j]) {
//                res[resl++] = chas[i++];
//                res[resr--] = chas[j--];
//            } else if (dp[i][j - 1] < dp[i + 1][j]) {
//                res[resl++] = chas[j];
//                res[resr--] = chas[j--];
//            } else {
//                res[resl++] = chas[i];
//                res[resr--] = chas[i++];
//            }
//        }
//        return new String(res);
//    }
//
//    public static void main(String[] args) {
//          String str="A1B21C";
//        System.out.println(getPalindrome1(str));
//    }
//}


/**
 * 括号字符串的有效性和最长有效长度
 * 1.问题1.给定一个字符串，判断是不是一个整体有效的字符串
 * 难度：*
 */
//public class Solution {
//    public static boolean isValid(String str) {
//        if (str == null || str.equals("")) {
//            return false;
//        }
//        char[] chars = str.toCharArray();
//        int status = 0;
//        for (int i = 0; i < chars.length; i++) {
//            if (chars[i] != ')' && chars[i] != '(') {
//                return false;
//            }
//            if (chars[i] == ')' && --status < 0) {
//                return false;
//            }
//            if (chars[i] == '(') {
//                status++;
//            }
//        }
//        return status == 0;
//    }
//    public static void main(String[] args) {
//        String str="(((())))()()()()()";
//        System.out.println(isValid(str));
//    }
//}

/**
 * 2.问题2.给定一个字符串str，返回最长的有效括号子串
 * 难度：**
 */
//public class Solution
//{
//    public static int maxLen(String str)
//    {
//        if(str==null||str=="")
//        {
//            return 0;
//        }
//        char[]chars=str.toCharArray();
//        int[]dp=new int[chars.length];
//        int pre=0;
//        int res=0;
//        for(int i=0;i<chars.length;i++)
//        {
//            if(chars[i]==')')
//            {
//                pre=i-dp[i-1]-1;
//                if(pre>=0&&chars[pre]=='(')
//                {
//                    dp[i]=dp[i-1]+2+(pre>0?dp[pre-1]:0);
//                }
//            }
//            res=Math.max(res,dp[i]);
//        }
//        return res;
//    }
//
//    public static void main(String[] args) {
//        String str="(())(((())))()()))))((()))))))))(((()))))";
//        System.out.println(maxLen(str));
//    }
//}

//import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;


import java_revise.QueueBaseArray;

import javax.print.attribute.standard.NumberUp;
import javax.swing.text.AttributeSet;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.*;
import java.util.logging.Logger;

/**
 * 公式字符串求值
 * 题目: 给定一个字符串str，str代表一个公式，公式里面
 * 那可能有整数，加减乘除符号或者左右括号，返回公式的计算结果
 * 难度：***
 */
//class Solution{
//    public static int getValue(String exp)
//    {
//        return value(exp.toCharArray(),0)[0];
//    }
//    public static int[] value(char[] chars, int i) {
//        Deque<String> deq = new LinkedList<>();
//        int pre = 0;
//        int[] bra = null;
//        while (i < chars.length && chars[i] != ')') {
//            if (chars[i] >= '0' && chars[i] <= '9') {
//                pre = pre * 10 + chars[i++] - '0';
//            } else if (chars[i] != '(') {
//                addNum(deq, pre);
//                deq.addLast(String.valueOf(chars[i++]));
//                pre = 0;
//            } else {
//                bra = value(chars, i + 1);
//                pre = bra[0];
//                i = bra[1] + 1;
//            }
//        }
//        addNum(deq, pre);
//        return new int[]{getNum(deq),i};
//    }
//
//    public static void addNum(Deque<String> deq, int num) {
//        if (!deq.isEmpty()) {
//            int cur = 0;
//            String top = deq.pollLast();
//            if (top.equals("+") || top.equals("-")) {
//                deq.addLast(top);
//            } else {
//                cur = Integer.valueOf(deq.pollLast());
//                num = top.equals("*") ? cur * num : cur / num;
//            }
//        }
//        deq.addLast(String.valueOf(num));
//    }
//
//    public static int getNum(Deque<String> deq) {
//        int res = 0;
//        boolean add = true;
//        String cur = null;
//        int num = 0;
//        while (!deq.isEmpty()) {
//            cur = deq.pollFirst();
//            if (cur.equals("+")) {
//                add = true;
//            } else if (cur.equals("-")) {
//                add = false;
//            } else {
//                num = Integer.valueOf(cur);
//                res += add ? num : (-num);
//            }
//        }
//        return res;
//    }
//
//    public static void main(String[] args) {
//        String str="48*((70-65)-43)+8*1";
//        System.out.println((getValue(str)));
//    }
//}


/**
 * 0左边必有1的二进制字符串数量   难度：***
 */
//
//class Solution
//{
//    public static void func(int a){
//         a=20;
//         System.out.println(a);
//
//    }
//
//    public static void main(String[] args) {
//        int a=10;//实参
//         func(a);
//    }
//}

/**
 * 双指针法
 */

/*
    public int minSubArrayLen(int s, int[] nums) {
        int i = 0;
        int j = 0;
        int curSum = 0;
        int minLength = nums.length + 1;
        while (j < nums.length) {
            if (curSum < s) {
                curSum += nums[j];
                j++;
            }
            while (curSum >= s) {
                minLength = Math.min(minLength, j - i);
                curSum = curSum - nums[i];
                i++;
            }
        }
        if (minLength > nums.length) {
            return 0;
        }else {
            return minLength;c
        }
    }
 */

//
//class Solution{
//    public static int characterReplacement(String s, int k) {
//    int max = 0, start = 0, end = 0, cur = 0;
//    int[] count = new int[26];
//    while (end < s.length()) {
//        cur = Math.max(cur, ++count[s.charAt(end) - 'A']);
//        while (end - start + 1 - cur > k)
//            count[s.charAt(start++) - 'A']--;
//        max = Math.max(max, end - start + 1);
//        end++;
//    }
//    return max;
//}
//
//    public static void main(String[] args) {
//        String s="ABAB";
//        System.out.println(characterReplacement(s,2));
//    }
//
//}

/**
 * 0左边必有1的二进制字符串数量
 */
/** 本质上是一个斐波拉契数列，唯一不同的地方是斐波拉契数列是1 1 2 3 5 8 13 ...
 *  *        我们这里是 1 2 3 5 8 13 ...
 *  方法1:O(N)时间复杂度
 *  方法2：O(logN) 矩阵乘法求解
 */


/**
 * 拼接所有的字符串产生字符顺序最小的大写字符串
 */
//class Solution {
//    public String lowestString(String[] strs) {
//        if (strs == null || strs.length == 0) {
//            return "";
//        }
//        Arrays.sort(strs, new Comparator<String>() {
//            @Override
//            public int compare(String o1, String o2) {
//                return (o1 + o2).compareTo(o2 + o1);
//            }
//        });
//        String res = "";
//        for (int i = 0; i < strs.length; i++) {
//            res += strs[i];
//        }
//        return res;
//    }
//}
//

/**
 * 找到字符串的最长的无重复得到字符串
 */
//class Solution {
//    public static int longestNoRepStr(String str) {
//        if(str.length()==0||str==null)
//        {
//            return 0;
//        }
//        int[] map = new int[256];
//        for (int i = 0; i < 256; i++) {
//            map[i] = -1;
//        }
//        int pre=-1;;
//        int len=0;
//        for(int i=0;i<str.length();i++){
//            pre=Math.max(pre,map[str.charAt(i)]);
//            len=Math.max(len,i-pre);
//            map[str.charAt(i)]=i;
//        }
//        return len;
//    }
//
//    public static void main(String[] args) {
//        String str="xinshangcong";
//        System.out.println(longestNoRepStr(str));
//    }
//}

/**
 * 找到指定的新类字符
 * 见《程序员代码面试指南》p302
 */

//class Solution {
//    public String pointNewchar(String s, int k) {
//        if (s == null || s.equals("") || k < 0 || k >= s.length()) {
//            return "";
//        }
//        char[] chas = s.toCharArray();
//        int uNum = 0;
//        for (int i = 0; i >= 0; i--) {
//            if (!Character.isUpperCase(chas[i])) {
//                break;
//            }
//            uNum++;
//        }
//        if ((uNum & 1) == 1) {
//            return s.substring(k - 1, k + 1);
//        }
//        if (Character.isUpperCase(chas[k])) {
//            return s.substring(k, k + 2);
//        }
//        return String.valueOf(chas[k]);
//    }
//}

/**
 * 旋变字符串问题
 * 难度: ****
 */
//class Solution {
//    public static boolean sameTypeSameNumber(char[] str1, char[] str2) {
//        if (str1.length != str2.length) {
//            return false;
//        }
//        int[] map = new int[256];
//        for (int i = 0; i < str1.length; i++) {
//            map[str1[i]]++;
//        }
//        for (int j = 0; j < str2.length; j++) {
//            if (--map[str2[j]] < 0) {
//                return false;
//            }
//        }
//        return true;
//    }
//
//    public static boolean process(char[] str1, char[] str2, int L1, int L2, int size) {
//        if (size == 1) {
//            return str1[L1] == str2[L2];
//        }
//        for (int leftPart = 1; leftPart < size; leftPart++) {
//            if (process(str1, str2, L1, L2, leftPart) && process(str1, str2, L1 + leftPart, L2 + leftPart, size - leftPart) ||
//                    process(str1, str2, L1, L2 + size - leftPart, leftPart) && process(str1, str2, L1 + leftPart, L2, size - leftPart)) {
//                return true;
//            }
//        }
//        return false;
//    }
//
//    public static boolean isScramble1(String s1, String s2) {
//        if ((s1 == null && s2 != null) || (s1 != null && s2 == null)) {
//            return false;
//        }
//        if (s1 == null && s2 == null) {
//            return true;
//        }
//        if (s1.equals(s2)) {
//            return true;
//        }
//        char[] str1 = s1.toCharArray();
//        char[] str2 = s2.toCharArray();
//        if (!sameTypeSameNumber(str1, str2)) {
//            return false;
//        }
//        int N = s1.length();
//        return process(str1, str2, 0, 0, N);
//    }
//
//    public static void main(String[] args) {
//        String s1="abcd";
//        String s2="acdb";
//        System.out.println(isScramble1(s1,s2));
//    }
//}
//


/**
 * 1048. 最长字符串链
 * 给出一个单词列表，其中每个单词都由小写英文字母组成。
 *
 * 如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，"abc" 是 "abac" 的前身。
 *
 * 词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。
 *
 * 从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。
 *示例：
 *
 * 输入：["a","b","ba","bca","bda","bdca"]
 * 输出：4
 * 解释：最长单词链之一为 "a","ba","bda","bdca"。
 */

//
//class Solution {
//    public static int longestStrChain(String[] words) {
//
//        Arrays.sort(words, new Comparator<String>() {
//            @Override
//            public int compare(String o1, String o2) {
//                return o1.length() - o2.length();
//            }
//        });
//
//        for(int i=0;i<words.length;i++)
//        {
//            System.out.println(words[i]);
//        }
//
//        if (words.length <= 0) {
//            return 0;
//        }
//        int[] dp = new int[words.length];
//        Arrays.fill(dp, 1);
//        for (int i = 0; i < words.length; i++) {
//            for (int j = 0; j < i; j++) {
//                if (isPre(words[j], words[i])) {
//                    dp[i] = Math.max(dp[i],dp[j] + 1);
//
//                }
//            }
//            System.out.println("i=="+i+"dp[i]=="+dp[i]);
//        }
//        int max = 1;
//        for (int i = 0; i < dp.length; i++) {
//            max = Math.max(max, dp[i]);
//        }
//        return max;
//    }
//
//    public static boolean isPre(String str1, String str2) {
//        if (str1.length() != str2.length() - 1) {
//            return false;
//        }
//        int dif = 0;
//        int i = 0;
//        int j = 0;
//
//        while (i < str1.length() && j < str2.length()) {
//            if (str1.charAt(i) != str2.charAt(j)) {
//                if (dif > 0) {
//                    return false;
//                } else {
//                    dif++;
//                    j++;
//                    continue;
//                }
//            } else {
//                i++;
//                j++;
//                continue;
//            }
//        }
//      return true;
//    }
//
//    public static void main(String[] args) {
//        String[] words = {"ksqvsyq","ks","kss","czvh","zczpzvdhx","zczpzvh","zczpzvhx","zcpzvh","zczvh","gr","grukmj","ksqvsq","gruj","kssq","ksqsq","grukkmj","grukj","zczpzfvdhx","gru"};
//
//        System.out.println(longestStrChain(words));
//
//        System.out.println(isPre("ks","kss"));
//    }
//}

/**
 *有一堆石头，每块石头的重量都是正整数。
 *
 * 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
 *
 * 如果 x == y，那么两块石头都会被完全粉碎；
 * 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
 * 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0
 *示例：
 *
 * 输入：[2,7,4,1,8,1]
 * 输出：1
 * 解释：
 * 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
 * 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
 * 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
 * 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
 */
//class Solution {
//    private static final int DEFAULT_INITIAL_CAPACITY = 1000;
//
//    public static int lastStoneWeight(int[] stones) {
//        int len = stones.length;
//        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(len / 2, new Comparator<Integer>() {
//            @Override
//            public int compare(Integer o1, Integer o2) {
//                return o2 - o1;
//            }
//        });
//        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
//        Arrays.sort(stones);
//        for (int i = 0; i < stones.length / 2; i++) {
//            maxHeap.add(stones[i]);
//        }
//        for (int j = stones.length / 2; j < stones.length; j++) {
//            minHeap.add(stones[j]);
//        }
//        while(!minHeap.isEmpty()&&!maxHeap.isEmpty())
//        {
//            int minHeadVal=minHeap.poll();
//            int maxHeadVal=maxHeap.poll();
//            int difVal=minHeadVal-maxHeadVal;
//            if(difVal>maxHeadVal)
//            {
//                minHeap.add(difVal);
//            }
//            else
//            {
//                maxHeap.add(difVal);
//            }
//        }
//        if(!minHeap.isEmpty())
//        {
//
//        }
//        return 0;
//    }
//}


/**
 *  最小包含字串的长度
 */
//class Solution {
//    public static int longestIncChild(String str1, String str2) {
//        int pre = -1;
//        int min = Integer.MAX_VALUE;
//        int i = 0;
//        int j = 0;
//        while (i < str1.length() && j < str2.length()) {
//            System.out.println("i=="+i+"j=="+j);
//            if (str1.charAt(i) == str2.charAt(j)) {
//                if (pre == -1) {
//                    pre = i;
//            }
//                if(j==0)
//                {
//                    pre=i;
//                }
//                if (j == str2.length() - 1) {
//                    min = Math.min(i - pre+1, min);
//                    i = pre + 1;
//                    j = 0;
//                    continue;
//                } else {
//                    i++;
//                    j++;
//                    continue;
//                }
//            } else {
//                i++;
//                continue;
//            }
//        }
//        return min;
//
//    }
//
//    public static void main(String[] args) {
//                String str1="adabbca";
//        String str2="acb";
//        System.out.println(longestIncChild(str1, str2));
//    }
//}

/**
 * 回文最小分割数
 */
//
//class Solution {
//    public static int minCount(String str) {
//        int len = str.length();
//        if (len <= 1) {
//            return 0;
//        }
//        char[] chars = str.toCharArray();
//        int[] dp = new int[len + 1];
//        dp[len]=-1;
//        boolean[][] p = new boolean[len][len];
//        for (int i = len - 1; i >= 0; i--) {
//            dp[i] = Integer.MAX_VALUE;
//            for (int j = i; j < len; j++) {
//                if (chars[i] == chars[j] && (j - i < 2 || p[i + 1][j - 1])) {
//                    p[i][j] = true;
//                    dp[i] = Math.min(dp[i], dp[j + 1] + 1);
//                }
//            }
//        }
//        return dp[0];
//    }
//
//    public static void main(String[] args) {
//        String str = "AC";
//        System.out.println(minCount(str));
//    }
//}
//
//
//class Solution
//{
//    public boolean isValid(char[] s,char[] e)
//    {
//        for(int i=0;i<s.length;i++)
//        {
//            if(s[])
//        }
//    }
//
//}


/**
 * 包含最小字串的长度
 */
//class Solution {
//    public static int minLength(String str1, String str2) {
//        char[] chas1 = str1.toCharArray();
//        char[] chas2 = str2.toCharArray();
//        int match = chas2.length;
//        int[] map = new int[256];
//        for(int i=0;i<chas2.length;i++)
//        {
//            map[chas2[i]]++;
//        }
//        int left = 0;
//        int right = 0;
//        int minLen = Integer.MAX_VALUE;
//        while (right != chas1.length) {
//            map[chas1[right]]--;
//            if (map[chas1[right]] >= 0) {
//                match--;
//            }
//            if (match == 0) {
//                while (map[chas1[left]] < 0) {
//                    map[chas1[left++]]++;
//                }
//                minLen = Math.min(minLen, right - left + 1);
//                System.out.println("minLen"+minLen);
//                match++;
//                map[chas1[left++]]++;
//            }
//            right++;
//
//        }
//        return minLen == Integer.MAX_VALUE ? 0 : minLen;
//    }
//
//    public static void main(String[] args) {
//        String str1="adabbca";
//        String str2="acb";
//        System.out.println(minLength(str1,str2));
//    }
//}

/**
 * 第八章；数组与矩阵问题
 */
//class Solution {
//    public List<Integer> spiralOrder(int[][] matrix) {
//
//        List<Integer> res = new ArrayList<Integer>();
//
//        if (matrix.length == 0) {
//            return res;
//        }
//
//        int rowBegin = 0;
//        int rowEnd = matrix.length-1;
//        int colBegin = 0;
//        int colEnd = matrix[0].length - 1;
//
//        while (rowBegin <= rowEnd && colBegin <= colEnd) {
//            // Traverse Right
//            for (int j = colBegin; j <= colEnd; j ++) {
//                res.add(matrix[rowBegin][j]);
//            }
//            rowBegin++;
//
//            // Traverse Down
//            for (int j = rowBegin; j <= rowEnd; j ++) {
//                res.add(matrix[j][colEnd]);
//            }
//            colEnd--;
//
//            if (rowBegin <= rowEnd) {
//                // Traverse Left
//                for (int j = colEnd; j >= colBegin; j --) {
//                    res.add(matrix[rowEnd][j]);
//                }
//            }
//            rowEnd--;
//
//            if (colBegin <= colEnd) {
//                // Traver Up
//                for (int j = rowEnd; j >= rowBegin; j --) {
//                    res.add(matrix[j][colBegin]);
//                }
//            }
//            colBegin ++;
//        }
//
//        return res;
//    }
//}

/**
 * 将正方形矩阵顺时针转动90°
 */
//class Solution {
//    public static void rorateNinthDegree(int[][] matrix) {
//        for (int i = 0; i < matrix.length; i++) {
//            for (int j = i; j < matrix[0].length; j++) {
//                swap(matrix, i, j);
//            }
//        }
//        reverseMatrix(matrix);
//        return;
//    }
//    public static void reverseMatrix(int[][] matrix) {
//        for (int i = 0; i < matrix.length; i++) {
//            int left = 0;
//            int right = matrix[0].length - 1;
//            while (left < right) {
//                int temp = matrix[i][left];
//                matrix[i][left] = matrix[i][right];
//                matrix[i][right] = temp;
//                right--;
//                left++;
//            }
//        }
//    }
//    public static void swap(int[][] matrix, int i, int j) {
//        int temp = matrix[i][j];
//        matrix[i][j] = matrix[j][i];
//        matrix[j][i] = temp;
//    }
//
//    public static void main(String[] args) {
//        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};
//        rorateNinthDegree(matrix);
//        for (int i = 0; i < matrix.length; i++) {
//            for (int j = 0; j < matrix[0].length; j++) {
//                if (j == matrix[0].length - 1) {
//                    System.out.print(matrix[i][j]);
//                    System.out.println();
//                } else {
//                    System.out.print(matrix[i][j] + " ");
//                }
//            }
//        }
//    }
//}
//
//class Solution
//{
//    public void printMatrixZigZig(int[][] matrix)
//    {
//        int tR=0;
//        int tC=0;
//        int dR=0;
//        int dC=0;
//        int endR= matrix.length-1;
//        int endC= matrix[0].length-1;
//        boolean fromUp=false;
//        while(tR!=endR+1)
//        {
//            printLevel()
//        }
//    }
//    public void printLevel(int[][]m,int tR,int tC,int dR,int dC,boolean f)
//    {
//        if(f)
//        {
//            while(tR!=dR+1){
//                System.out.println(m[tR++][tC--]+" ");
//            }
//        }
//        else
//        {
//
//        }
//    }
//}

/**
 * 遍历二叉树的神级方法
 */
//class Solution
//{
//    public static void dfsWithO1(TreeNode root)
//    {
//        TreeNode cur=root;
//
//        while(cur!=null)
//        {
//
//            if(cur.left!=null)
//            {
//
//                TreeNode node=cur.left;
//                while(node.right!=null&&node.right!=cur)
//                {
//                    node=node.right;
//                }
//                if(node.right==null)
//                {
//                    node.right=cur;
//                    cur=cur.left;
//                    continue;
//                }
//                else
//                {
//                    node.right=null;
//                }
//            }
//            System.out.println(cur.val);
//            cur=cur.right;
//
//        }
//    }
//
//    public static void main(String[] args) {
//        TreeNode root=new TreeNode(5);
//        TreeNode left1=new TreeNode(4);
//        TreeNode left2=new TreeNode(3);
//        TreeNode left3=new TreeNode(2);
//        TreeNode right1=new TreeNode(6);
//        TreeNode right2=new TreeNode(7);
//        root.left=left1;
//        left1.left=left2;
//        left1.right=left3;
//        root.right=right1;
//        right1.left=right2;
//        dfsWithO1(root);
//    }
//}

/**
 * 未排序数组中累加和为给定值的最长子数组系列问题
 */
//class Solution {
//    public int findLongestChildArr(int[] arr, int K) {
//        Map<Integer, Integer> map = new HashMap<>();
//        int sum = 0;
//        int maxLen = 0;
//        for (int i = 0; i < arr.length; i++) {
//            sum += arr[i];
//            if (map.containsKey(sum - K)) {
//                maxLen = Math.max(maxLen, i - map.get(sum - K));
//            }
//            if (!map.containsKey(sum)) {
//                map.put(sum, i);
//            }
//        }
//        return maxLen;
//    }
//}

/**
 * 在二叉树中找到累加和为指定值的最长路径
 * 时间复杂度:O(N)
 * 空间复杂度:O(h)
 */
//class Solution {
//    static class Node {
//        int val;
//        Node left;
//        Node right;
//
//        public Node(int val) {
//            this.val = val;
//        }
//    }
//
//    private static int maxLen = 0;
//
//    public static int getMaxLength(Node head, int K) {
//        HashMap<Integer, Integer> map = new HashMap<>();
//        map.put(0, 0);
//        preOrder(head, K, 1, 0, map);
//        return maxLen;
//    }
//
//    public static void preOrder(Node head, int K, int level, int preSum, HashMap<Integer, Integer> map) {
//        if (head == null) {
//            return;
//        }
//        int curSum = preSum + head.val;
//        if (!map.containsKey(curSum)) {
//            map.put(curSum, level);
//        }
//        if (map.containsKey(curSum - K)) {
//            maxLen = Math.max(maxLen, level - map.get(curSum - K));
//        }
//        preOrder(head.left, K, level + 1, curSum, map);
//        preOrder(head.right, K, level + 1, curSum, map);
//        if (level == map.get(curSum)) {
//            map.remove(curSum);
//        }
//    }
//
//    public static void main(String[] args) {
//        Node root=new Node(-3);
//        root.left=new Node(3);
//        root.left.left=new Node(1);
//        root.left.right=new Node(0);
//        root.left.right.left=new Node(1);
//        root.left.right.right=new Node(6);
//        root.right=new Node(-9);
//        root.right.left=new Node(2);
//        root.right.right=new Node(1);
//        System.out.println(getMaxLength(root,6));
//    }
//}

/**
 * 二叉树的按层打印与zigzig打印
 */

//class Solutiion {
//    static class Node {
//        public int val;
//        Node left;
//        Node right;
//
//        public Node(int val) {
//            this.val = val;
//        }
//    }
//    public static void printByZigZig(Node root) {
//        Queue<Node> queue = new LinkedList<>();
//        ((LinkedList<Node>) queue).push(root);
//        int level = 1;
//        System.out.print("level " + level++ + " :");
//        Node last = root;
//        Node nLast = null;
//        while (!queue.isEmpty()) {
//            Node node = queue.poll();
//            System.out.print(" " + node.val);
//            if (node.left != null) {
//                ((LinkedList<Node>) queue).offer(node.left);
//                nLast = node.left;
//            }
//            if (node.right != null) {
//                ((LinkedList<Node>) queue).offer(node.right);
//                nLast = node.right;
//            }
//            if (node == last && !queue.isEmpty()) {
//                System.out.println();
//                System.out.print("level " + level++ + " :");
//                last = nLast;
//            }
//        }
//        return;
//    }
//
//    public static void main(String[] args) {
//        Node root = new Node(5);
//        root.left = new Node(3);
////        root.left.right = new Node(4);
////        root.right = new Node(6);
////        root.right.right = new Node(7);
//        printByZigZig(root);
//    }
//}

/**
 * 画匠问题
 */
//class Solution
//{
//    public static int solution1(int[]arr,int num)
//    {
//        if(arr==null||arr.length==0||num==0)
//        {
//            throw new RuntimeException("err");
//        }
//        int[]sumArr=new int[arr.length];
//        int[]map=new int[arr.length];
//        sumArr[0]=arr[0];
//        map[0]=arr[0];
//        for(int i=1;i<arr.length;i++)
//        {
//            sumArr[i]=sumArr[i-1]+arr[i];
//            map[i]=sumArr[i];
//        }
//        for(int i=1;i<num;i++)
//        {
//            for(int j=map.length-1;j>i-1;j--)
//            {
//                int min=Integer.MAX_VALUE;
//                for(int k=i-1;k<j;k++)
//                {
//                    int cur=Math.max(map[k],sumArr[j]-sumArr[k]);
//                    min=Math.min(min,cur);
//                }
//                map[j]=min;
//                System.out.println("map["+j+"]=="+map[j]);
//            }
//        }
//        return map[arr.length-1];
//    }
//    public static void main(String[] args) {
//        int[]arr={1,1,1,4,3};
//        int num=3 ;
//        System.out.println(solution1(arr,num));
//    }
//}

/**
 * 输入：[1,1,4,2,1,3]
 * 输出：3
 * 解释：
 * 高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
 */
//class Solution {
//    public static int heightChecker(int[] heights) {
//      int[]temp=new int[heights.length];
//      for(int k=0;k<heights.length;k++){
//          temp[k]=heights[k];
//      }
//      Arrays.sort(temp);
//      int res=0;
//      for(int i=0;i<temp.length;i++){
//          if(heights[i]!=temp[i]){
//              res++;
//          }
//      }
//      return res;
//    }
//
//    public static void main(String[] args) {
//        int[]heights={1,1,4,2,1,3};
//        System.out.println(heightChecker(heights));
//    }
//
//}

/**
 * [4,10,10]
 * [1,1,0]
 * 2
 */
//class Solution {
//    public static int maxSatisfied(int[] customers, int[] grumpy, int X) {
//        int[] angryNum=new int[customers.length];
//        int cusNum=0;
//        for(int i=0;i<customers.length;i++)
//        {
//            cusNum+=customers[i];
//        }
//        if(X>=customers.length){
//            return cusNum;
//        }
//        for(int i=0;i<customers.length;i++)
//        {
//            if(grumpy[i]==1){
//                angryNum[i]=customers[i];
//            }
//        }
//        int []angrySum=new int[angryNum.length];
//        angrySum[0]=angryNum[0];
//        for(int m=1;m<angryNum.length;m++)
//        {
//            angrySum[m]=angrySum[m-1]+angryNum[m];
//            System.out.println("angrySum["+m+"]=="+angrySum[m]);
//        }
//        int angryValidNum=Integer.MIN_VALUE;
//
//        for(int k=0;k<=angryNum.length-X;k++)
//        {
//            if(k==0){
//                angryValidNum=Math.max(angrySum[X-1],angryValidNum);
//            }else
//            {
//                angryValidNum=Math.max(angryValidNum,angrySum[k+X-1]-angrySum[k-1]);
//            }
//        }
//        return cusNum-(angrySum[angrySum.length-1]-angryValidNum);
//    }
//
//    public static void main(String[] args) {
//        int[]customers = {4,10,10};
//        int[]grumpy = {1,1,0};
//        int X = 2;
//        System.out.println(maxSatisfied(customers,grumpy,X));
//    }
//}

//class Solution {
//    public int[] rearrangeBarcodes(int[] barcodes) {
//        Map<Integer, Integer> map = new HashMap<>();
//        for(int barcode: barcodes){
//            map.put(barcode, map.getOrDefault(barcode, 0)+1);
//        }
//        int len = barcodes.length;
//        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->b[1]-a[1]);
//        for(Map.Entry<Integer, Integer> entry: map.entrySet()){
//            q.offer(new int[]{entry.getKey(), entry.getValue()});
//        }
//        int[] now = q.poll(), res = new int[len];
//        for(int i=0; i<len; i+=2){
//            if(now[1]<=0){
//                now = q.poll();
//            }
//            res[i] = now[0];
//            now[1] -= 1;
//        }
//
//        for(int i=1; i<len; i+=2){
//            if(now[1]<=0){
//                now = q.poll();
//            }
//            res[i] = now[0];
//            now[1] -= 1;
//        }
//        return res;
//    }
//}
//
//class Solution {
//    public int[] prevPermOpt1(int[] A) {
//        Map<Integer, Integer> map = new HashMap<>();
//        int a, t;
//        for (int i = A.length - 1; i >= 0; i--) {
//            a = t = A[i];
//            while (--t >= 0) {
//                if (map.containsKey(t)) {
//                    int j = map.get(t);
//                    A[i] = A[j];
//                    A[j] = a;
//                    return A;
//                }
//            }
//            int idx = i;
//            map.compute(a, (k, v) -> v == null || v > idx ? idx : v);
//        }
//        return A;
//    }
//}

//
//class Solution {
//    public static String gcdOfStrings(String str1, String str2) {
//        int len1 = str1.length();
//        int len2 = str2.length();
//        if (str1.length() >= str2.length()) {
//            int k = len1 / len2;
//            int i = 0;
//            while (k-- > 0) {
//                if (!str1.substring(i, i + str2.length()).equals(str2)) {
//                    return "";
//                }
//                i=i+str2.length();
//            }
//            if (i == str1.length()) {
//                return str2;
//            } else {
//                return gcdOfStrings(str2, str1.substring(i, str1.length()));
//            }
//        }
//        if (str1.length() < str2.length()) {
//            int k = len2 / len1;
//            int i = 0;
//            while (k-- > 0) {
//                if (!str2.substring(i, i + str1.length()).equals(str1)) {
//                    return "";
//                }
//                i=i+str1.length();
//            }
//            if (i == str2.length()) {
//                return str1;
//            } else {
//                return gcdOfStrings(str1, str2.substring(i, str2.length()));
//            }
//        }
//        return "";
//    }
//
//    public static void main(String[] args) {
//        String str1="ABABAB";
//        String str2="ABAB";
//        System.out.println(gcdOfStrings(str1,str2));
//    }
//}

//class Solution {
//    public static int[] addNegabinary(int[] arr1, int[] arr2) {
//        if (arr1 == null || arr2 == null) {
//            return null;
//        }
//
//        int N1 = calculateBaseMinusTwo(arr1);
//        int N2 = calculateBaseMinusTwo(arr2);
//        int N = N1 + N2;
//        String res = baseNeg2(N);
//        int[] ret = new int[res.length()];
//        for (int i = 0; i < res.length(); i++) {
//            ret[i] = res.charAt(i) - '0';
//        }
//        return ret;
//    }
//    public static int calculateBaseMinusTwo(int[] arr) {
//        int res = 0;
//        int n=arr.length-1;
//        for (int i = arr.length - 1; i >= 0; i--) {
//            Double val = arr[i] * Math.pow(-2, n-i);
//            res += val;
//        }
//        return res;
//    }
//    public static String baseNeg2(int N) {
//        String res = "";
//        while (N != 0) {
//            res = Integer.toString(N & 1) + res;
//            N = -(N >> 1);
//        }
//        return res == "" ? "0" : res;
//    }
//
//    public static void main(String[] args) {
//        int[]arr1={1,0,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1,0,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0};
//        int[]arr2={1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,1,0,0,0,0,1,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,1,1,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,1,1,0,1,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,1};
//        int[]res=addNegabinary(arr1,arr2);
//        for(int i=0;i<res.length;i++)
//        {
//            System.out.print(res[i]+" ");
//        }
//
//    }
//}
//
//
//class Solution {
//    public static int[] addNegabinary(int[] arr1, int[] arr2) {
//
//        int maxLen = Math.max(arr1.length, arr2.length);
//        String res = "";
//        int i = arr1.length - 1;
//        int j = arr2.length - 1;
//        int pre = 0;
//        int k = 0;
//        while (i >= 0 || j >= 0) {
//            if (j < 0) {
//                if (k % 2 == 0) {
//                    res = (arr1[i] + pre) % 2 + res;
//                    pre = arr1[i--] / 2;
//                    k++;
//                } else {
//                    res = Math.abs(arr1[i] - pre) % 2 + res;
//                    pre = Math.abs(arr1[i--] - pre) / 2;
//                    k++;
//                }
//            } else if (i < 0) {
//                if (k % 2 == 0) {
//                    res = (arr2[j] + pre) % 2 + res;
//                    pre = (arr2[j--] + pre) / 2;
//                    k++;
//                } else {
//                    res = Math.abs(arr2[j] - pre) % 2 + res;
//                    pre = Math.abs(arr2[j--] - pre) / 2;
//                    k++;
//                }
//            } else if (k % 2 == 0) {
//
//                res = (arr1[i] + arr2[j] + pre) % 2 + res;
//                pre = (arr1[i--] + arr2[j--] + pre) / 2;
//                k++;
//            } else {
//                int val = Math.abs(Math.abs(arr1[i--] - arr2[j--]) - pre);
//                res = val % 2 + res;
//                pre = val / 2;
//                k++;
//            }
//        }
//        int[] ret = new int[res.length()];
//        for (int m = 0; m < res.length(); m++) {
//            ret[m] = res.charAt(m) - '0';
//        }
//        return ret;
//    }
//
//}
//
//class Solution
//{
//    static abstract class Human{}
//    static class Man extends Human{
//
//    }
//    static class Woman extends Human{}
//    public void sayHello(Human guy){
//        System.out.println("hello guy");
//    }
//    public void sayHello(Man guy){
//        System.out.println("hello Man");
//    }
//    public void sayHello(Woman guy){
//        System.out.println("hello woman");
//    }
//
//    public static void main(String[] args) {
//        Human woman=new Woman();
//        Human man=new Man();
//        Solution solution=new Solution();
//        solution.sayHello((Woman)woman);
//        solution.sayHello((Man)man);
//    }
//}
//
//class Solution {
////    public static void sayHello(Object args) {
////        System.out.println("hello object");
////    }
////    public static void sayHello(int arg){
////        System.out.println("hello int");
////    }
////    public static void sayHello(long args){
////        System.out.println("hello long");
////    }
////    public static void sayHello(Character arg){
////        System.out.println("hello Character");
////    }
//
////    public static void sayHello(char  arg){
////        System.out.println("hello char");
////    }
//    public static void sayHello(char... arg){
//        System.out.println("hello char...");
//    }
////    public static void sayHello(Serializable arg){
////        System.out.println("hello Serialiable");
////    }
//
//    public static void main(String[] args) {
////        sayHello('a');
//    }
//
//}
//
//class Solution {
//
//    /**
//     * 位运算实现加减乘除
//     * @param args
//     */
//    public static int add(int a, int b) {
//        int sum = a;
//        while (b != 0) {
//            sum = a ^ b;
//            b = (a & b) << 1;
//            a = sum;
//        }
//        return sum;
//    }
//    public static int minus(int a,int b)
//    {
//        return add(a,negNum(b));
//    }
//    public static int negNum(int n)
//    {
//        return add(~n,1);
//    }
//    public static int multi(int a,int b)
//    {
//        int res=0;
//        while(b!=0){
//            if((b&1)!=0){
//                res=add(res,a);
//            }
//            a<<=1;
//            b>>>=1;
//        }
//        return res;
//    }
//
//    public static void main(String[] args) {
//        int a = 1;
//        int b = 2;
//        a = a ^ b;
//        b = a ^ b;
//        a = a ^ b;
//        System.out.println("a=" + a);
//        System.out.println("b=" + b);
////        System.out.println(add(2,3));
////        System.out.println(minus(2,3));
//        System.out.println(multi(2,3));
//    }
//}
//class Solution {
//    public class Node {
//        public int value;
//        public Node next;
//    }
//
//    public static Node getLastExistedNode(Node head, int m) {
//        Node last = head;
//        while (last.next != head) {
//            last = last.next;
//        }
//
//        int k = 0;
//        while (last!= head) {
//            if (++k == m){
//                last.next=head.next;
//                 k=0;
//            }else
//            {
//                last=last.next;
//            }
//            head=last.next;
//        }
//        return head;
//    }
//}


/**
 * 将搜索二叉树转换为双向链表
 */
class Solution {
    static class Node {
        private int val;
        Node left;
        Node right;

        public Node(int val) {
            this.val = val;
        }
    }
//
//    private static Node head = null;
//    private static Node tail = null;
//
//    public static Node convertToLinkedList(Node head) {
//        convert(head);
//        return head;
//    }
//
//    public static void convert(Node head) {
//        if (head == null) {
//            return;
//        }
//        convert(head.left);
//        createList(head);
//        convert(head.right);
//    }
//
//    public static void createList(Node cur) {
//        cur.left = tail;
//        if (tail == null) {
//            head = cur;
//        } else {
//            tail.right = cur;
//        }
//        tail = tail.right;
//    }


    /**
     * 数组中出现次数超过一半的数字
     *
     * @param args
     */
    public static int findOccurTimeSupreOfHalf(int[] arr) {
        int mid = findOccurTimeSupreOfHalfMethod(arr, 0, arr.length - 1);
        return arr[mid];

    }

    public static int findOccurTimeSupreOfHalfMethod(int[] arr, int lo, int hi) {
        if (lo >= hi) {
            return lo;
        }
        int mid = partition(arr, lo, hi);

        if (mid == (lo + hi) >> 1) {
            return mid;
        } else if (mid < (lo + hi) >> 1) {
            lo = mid + 1;
            findOccurTimeSupreOfHalfMethod(arr, lo, hi);
        } else {
            hi = mid - 1;
            findOccurTimeSupreOfHalfMethod(arr, lo, hi);
        }
        return lo;
    }

    public static int partition(int[] arr, int left, int right) {
        int temp = arr[left];
        while (left < right) {
            while (left < right && arr[right] > temp) {
                right--;
            }
            if (left < right) {
                arr[left] = arr[right];
                left++;
            }
            while (left < right && arr[left] < temp) {
                left++;
            }
            if (left < right) {
                arr[right] = arr[left];
                right--;
            }
        }
        arr[left] = temp;
        return left;
    }

    /**
     * 最小的k个数
     * 输入n个整数，找出其中最小的k个数
     *
     * @param args
     */

    public static int findKthSmallNumber(int[] arr, int k) {
        return findKthSmallNumberMethod(arr, 0, arr.length - 1, k);
    }

    public static int findKthSmallNumberMethod(int[] arr, int lo, int hi, int k) {
        if (lo >= hi) {
            return lo;
        }
        int mid = partition(arr, lo, hi);
        if (mid == k - 1) {
            return mid;
        } else if (mid < k - 1) {
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
        return findKthSmallNumberMethod(arr, lo, hi, k);
    }

    /**
     * 连续子数组的最大和
     *时间复杂度O(N)
     * @param args
     */

    /**
     * 使用动态规划
     * @param arr
     * @return
     */
    public static int MaxSumOfConsecutiveChildArray(int[] arr) {
//        int max = Integer.MIN_VALUE;
        int[] dp = new int[arr.length];
        dp[0] = arr[0];
        int max = dp[0];
        for (int i = 1; i < arr.length; i++) {
            if (dp[i - 1] < 0) {
                dp[i] = arr[i];
            } else {
                dp[i] = arr[i] + dp[i - 1];
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }

    /**
     * 1~n中1出现的次数
     * @param args
     */

//    public static int ZeroTimesOf12n(int n) {


//    }

    /**
     * 把数组排成最小的数
     * @param args
     */
    public static void rebuildArray(int[] arr) {

    }

    /**
     * 数字字符串转换为字母组合的总数
     * @param args
     */
    public static int num(String str) {
        if (str == null || str.equals("")) {
            return 0;
        }
        int cur = str.charAt(str.length() - 1) == '0' ? 0 : 1;
        int next = 0;
        for (int i = str.length() - 2; i >= 0; i--) {
            if (str.charAt(i) == '0') {
                next = cur;
                cur = 0;
            } else {
                int temp = cur;
                if ((str.charAt(i) - '0') * 10 + str.charAt(i + 1) - '0' < 27) {
                    cur += next;
                }
                next = temp;
            }
        }
        return cur;
    }

    /**
     * 最长不含重复字符的子字符串
     * @param args
     */
    public static String longestNoRepChildStr(String str) {

        if (str == null || str.equals("")) {
            return "";
        }
        char[] chas = str.toCharArray();
        int[] map = new int[26];
        Arrays.fill(map, -1);
        int max = 0;
        int pre = -1;
        int cur = 0;
        int left = 0;
        int right = 0;
        for (int i = 0; i < chas.length; i++) {
            pre = Math.max(pre, map[chas[i] - 'a']);
            cur = i - pre;
            if (cur > max) {
                if (pre == -1) {
                    left = 0;
                    right = i + 1;
                } else {
                    left = pre + 1;
                    right = i + 1;
                }
            }
            max = Math.max(max, cur);
            map[chas[i] - 'a'] = i;
        }

        return str.substring(left, right);

    }

    /**
     * 逆序对数目
     * @param args
     */
    public static int reversePairsNumber(int[] arr) {
        return reversePairsNumberMethod(arr, 0, arr.length - 1);
    }

    public static int reversePairsNumberMethod(int[] arr, int lo, int hi) {
        if (lo >= hi) {
            return 0;
        }
        int mid = (lo + hi) >> 1;
        int left = reversePairsNumberMethod(arr, lo, mid);
        int right = reversePairsNumberMethod(arr, mid + 1, hi);
        int count = merge(arr, lo, mid, hi);
        return left + right + count;
    }

    public static int merge(int[] arr, int left, int mid, int right) {
        int[] aux = new int[arr.length];
        for (int k = 0; k < arr.length; k++) {
            aux[k] = arr[k];
        }
        int i = mid;
        int j = right;
        int count = 0;
        for (int m = right; m >= left; m--) {
            if (i < left) {
                arr[m] = aux[j--];
            } else if (j < mid + 1) {
                arr[m] = aux[i--];
            } else if (aux[i] <= aux[j]) {
                arr[m] = aux[j--];
            } else {
                count += j - mid;
                arr[m] = aux[i--];
            }
        }
        return count;
    }

    /**
     * 匹配字符串
     */

    public static boolean isMatch(String s, String p) {
        if (s == null || p == null) {
            return false;
        }
        if (s == null && p == null) {
            return true;
        }
        char[] cs = s.toCharArray();
        char[] cp = p.toCharArray();
        return helper(cs, 0, cp, 0);
    }

    public static boolean helper(char[] cs, int i, char[] cp, int j) {
        if (i >= cs.length && j >= cp.length) {
            return true;
        }
        if (j >= cp.length) {
            return false;
        }
        if (j + 1 < cp.length && cp[j + 1] == '*') {
            if (cs[i] == cp[j] || cp[j] == '.') {
                return helper(cs, i + 1, cp, j) || helper(cs, i + 1, cp, j + 2) || helper(cs, i, cp, j + 2);
            } else {
                return helper(cs, i, cp, j + 2);
            }
        }
        if (cs[i] == cs[j] || cp[j] == '.' && i < cs.length) {
            return helper(cs, i + 1, cp, j + 1);
        }
        return false;
    }

    /**
     * 未排序整数数组中累加和为给定值的最长子数组长度
     */
    public static int getLongestChildArrInArr(int[] arr, int k) {
        int left = 0;
        int right = 0;
        int len = 0;
        int sum = 0;
        while (right < arr.length) {
            if (k == sum) {
                len = Math.max(len, right - left + 1);
                sum -= arr[left++];
            } else if (k > sum) {
                right++;
                if (right >= arr.length) {
                    break;
                }
                sum += arr[right];
            } else {
                sum -= arr[left];
                left++;
            }
        }
        return len;
    }

    /**
     * 自然数数组的排序
     */
    public static void sortNatureNumber(int[] arr) {

        int temp = 0;
        int next = 0;
        for (int i = 0; i < arr.length; i++) {
            temp = arr[i];
            while (arr[i] != i + 1) {
                next = arr[temp - 1];
                arr[temp - 1] = temp;
                temp = next;
            }
        }
    }


    public static int lastStrLength(int n, String str) {
        int i = 0;
        while (i < str.length() - 1) {
            if (str.charAt(i) != str.charAt(i + 1)) {
                if (i != 0 && i < str.length() - 2) {
                    str = str.substring(0, i) + str.substring(i + 2, str.length());
                    i = i - 1;
                    continue;
                }
                if (i == 0 && i + 2 < str.length()) {
                    str = str.substring(i + 2, str.length());
                    continue;
                }
                if (i == str.length() - 2) {
                    str = str.substring(0, i);
                    continue;
                }
            } else {
                i++;
            }
        }
        return str.length();
    }

    public static int helper(int n, String str) {
        if (str.length() <= 0) {
            return 0;
        }
        Stack<Character> stack = new Stack<Character>();
//        int i=1;
        stack.push(str.charAt(0));
        int i = 1;
        while (i < str.length()) {
            if (!stack.isEmpty()) {
                char topChar = stack.peek();
                if (topChar != str.charAt(i)) {
                    stack.pop();
                    i++;
                    continue;
                } else {
                    stack.push(str.charAt(i));
                    i++;
                    continue;
                }
            } else {
                stack.push(str.charAt(i));
                i++;
                continue;
            }
        }
        return stack.size();
    }


    /**
     * 数据与矩阵问题
     */
    /**
     * 1 2 3
     * 4 5 6
     * 7 8 9
     * @param arr
     */
    public static void printMethod(int[][] arr) {
        int rt = 0;
        int rd = arr.length - 1;
        int ct = 0;
        int cd = arr[0].length - 1;
        while (rt <= rd && ct <= cd) {
            printWithRotation(arr, rt++, rd--, ct++, cd--);
        }

    }

    public static void printWithRotation(int[][] arr, int rt, int rd, int ct, int cd) {
        if (rt == rd) {
            for (int j = ct; j <= cd; j++) {
                System.out.println(arr[rt][j]);
            }
        } else if (ct == cd) {
            for (int i = rt; i <= rd; i++) {
                System.out.println(arr[i][ct]);
            }
        } else {
            int curR = rt;
            int curC = ct;
            while (curC != cd) {
                System.out.println(arr[curR][curC]);
                curC++;
            }
            while (curR < rd) {
                System.out.println(arr[curR][curC]);
                curR++;
            }
            while (curC != ct) {
                System.out.println(arr[curR][curC]);
                curC--;
            }
            while (curR != rt) {
                System.out.println(arr[curR][curC]);
                curR--;
            }
        }
    }

    public static int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] map = new int[1001];
        for (int i = 0; i < arr1.length; i++) {
            map[arr1[i]]++;
        }
        int k = 0;
        for (int j = 0; j < arr2.length; j++) {
            int time = map[arr2[j]];
            while (time-- > 0) {
                arr1[k++] = arr2[j];
                map[arr2[j]]--;
            }
        }
        for (int j = 0; j < map.length; j++) {
            if (map[j] != 0) {
                int time = map[j];
                while (time-- > 0) {
                    arr1[k++] = j;
                }
            }
        }
        return arr1;
    }


    public static int findCircleNum(int[][] M) {
        UF uf = new UF(M.length);
        for (int i = 0; i < M.length - 1; i++) {
            for (int j = i + 1; j < M.length; j++) {
                if (M[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }
        return uf.count;

    }

    static class UF {
        public int count;
        private int[] id;
        private int[] sz;

        public UF(int N) {
            id = new int[N];
            for (int i = 0; i < N; i++) {
                id[i] = i;
            }
            sz = new int[N];

            this.count = N;
        }

        public int find(int k) {
            while (id[k] != k) {
                id[k] = id[id[k]];
                k = id[k];
            }
            return k;
        }

        public boolean isConnection(int m, int n) {
            int p = find(m);
            int q = find(n);
            if (p == q) {
                return true;
            }
            return false;
        }

        public void union(int m, int n) {
            if (isConnection(m, n)) {
                return;
            }
            int p = find(m);
            int q = find(n);
            if (sz[p] < sz[q]) {
                id[p] = q;
                sz[q] += sz[p];
            } else {
                id[q] = p;
                sz[p] += sz[q];
            }
            count--;

        }
    }

    public static int maxNumberOfBalloons(String text) {
        Map<Character, Integer> map = new HashMap<>();
        map.put('b', 0);
        map.put('a', 0);
        map.put('l', 0);
        map.put('o', 0);
        map.put('n', 0);
        for (int i = 0; i < text.length(); i++) {
            char ch = text.charAt(i);
            if (map.containsKey(text.charAt(i))) {
                int time = map.get(ch);
                map.put(ch, time + 1);
            }
        }
        int minTime = Integer.MAX_VALUE;
        int lTime = Integer.MAX_VALUE;
        int oTime = Integer.MAX_VALUE;
        for (Character ch : map.keySet()) {
            if (ch == 'l') {
                lTime = Math.min(lTime, map.get(ch));
            } else if (ch == 'o') {
                oTime = Math.min(oTime, map.get(ch));
            } else {
                minTime = Math.min(minTime, map.get(ch));
            }
        }
        return Math.min(minTime, Math.min(oTime >> 1, lTime >> 1));
    }


    /**
     *输入：s = "(ed(et(oc))el)"
     * 输出："leetcode"
     * @param args
     */
    public static String reverseParentheses(String s) {
        Stack<Character> stack = new Stack<>();
        Queue<Character> queue = new LinkedList<>();
        int i = 0;
        int N = s.length();
        while (i < N) {
            char ch = s.charAt(i);
            if (ch == '(') {
                stack.push(ch);
            } else if (Character.isLetter(ch)) {
                stack.push(ch);
            } else {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    queue.offer(stack.pop());
                }
                if (!stack.isEmpty()) {
                    stack.pop();
                }
                while (!queue.isEmpty()) {
                    stack.push(queue.poll());
                }
            }
            i++;
        }
        String ret = "";
        while (!stack.isEmpty()) {
            ret = stack.pop() + ret;
        }
        return ret;
    }


    /**输入：arr = [1,-2,1], k = 5
     输出：2
     */

    public static int calculateMinArrVal(int[] arr) {
        int cur = 0;
        int max = cur;
        int i = 0;
        while (i < arr.length) {
            if (arr[i] >= 0) {
                cur += arr[i];
                max = Math.max(max, cur);
            } else {
                if (cur + arr[i] >= 0) {
                    cur += arr[i];
                } else {
                    cur = 0;
                }
            }
            i++;
        }
        return max;
    }

    //
//    public static List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
//        int[] conn = new int[n];
//        for (int i = 0; i < connections.size(); i++) {
//            conn[connections.get(i).get(0)]++;
//            conn[connections.get(i).get(1)]++;
//        }
//        List<List<Integer>> ret = new ArrayList<>();
//        for (int j = 0; j < conn.length; j++) {
//            if (conn[j] == 1) {
//                for (int k = 0; k < connections.size(); k++) {
//                    if (connections.get(k).get(0) == j) {
//                        List<Integer> temp = new ArrayList<>();
//                        temp.add(connections.get(k).get(0));
//                        temp.add(connections.get(k).get(1));
//                    }
//                    if (connections.get(k).get(1) == j) {
//                        List<Integer> temp = new ArrayList<>();
//                        temp.add(connections.get(k).get(0));
//                        temp.add(connections.get(k).get(1));
//                    }
//                }
//            }
//        }
//        return ret;
//    }
//    public int kConcatenationMaxSum(int[] arr, int k) {
//        long sum = 0;
//        for (int a : arr) sum += a;
//
//        int mod = 1000000007;
//        long res = 0;
//        int n = arr.length;
//        int[] dp = new int[n + 1];
//        for (int i = 0; i < n; i++) {
//            dp[i + 1] = Math.max(dp[i] + arr[i], arr[i]);
//            res = Math.max(res, dp[i + 1]);
//        }
//
//        if (k == 1) return (int) (res % mod);
//
//        long first = arr[0];
//        int cur = 0;
//        for (int i = 0; i < n; i++) {
//            cur += arr[i];
//            first = Math.max(first, cur);
//        }
//
//        res = Math.max(res, first + dp[n]);
//        if (sum > 0) {
//            long tmp = sum * (k - 2) + dp[n] + first;
//            res = Math.max(res, tmp);
//        }
//        return (int) (res % mod);
//    }

    /**
     * 输入一个正数n，输出所有和为n 连续正数序列
     * @param args
     */
    private static int count = 0;


    public static int getSequence(int target) {
        for (int i = 1; i < target; i++) {
            sequenceSolved(target, i);
        }
        return count;
    }

    public static void sequenceSolved(int target, int i) {
        if (target == 0) {
            count++;
            return;
        }
        if (target < 0) {
            return;
        }
        sequenceSolved(target - i, i + 1);
    }

    public static void main(String[] args) {
        System.out.println(getSequence(1000));


//        System.out.println(maxNumberOfBalloons("ballon"));
//        Scanner in = new Scanner(System.in);
//        while (in.hasNext()) {
//            String input1Str = in.nextLine();
//            String[] input1 = input1Str.split(" ");
//            int n = Integer.parseInt(input1[0]);
//            int m = Integer.parseInt(input1[1]);
//            int k = Integer.parseInt(input1[2]);
//            int[][] languages = new int[k][2];   //确定已经掌握了一些语言的人
//            for (int i = 0; i < k; i++) {
//                String inputStr = in.nextLine();
//                String[] input = inputStr.split(" ");
//                languages[i][0] = Integer.parseInt(input[0]);
//                languages[i][1] = Integer.parseInt(input[1]);
//            }
//            Arrays.sort(languages, new Comparator<int[]>() {
//                @Override
//                public int compare(int[] o1, int[] o2) {
//                    return o1[1] - o2[1];
//                }
//            });
//            if (languages == null || languages.length == 0) {
//                System.out.println(n);
//            }
//            int[][] relations = new int[n][n];  //创建掌握共同语言的人的关系图
//            int num = languages[0][0];
//            int language = languages[0][1];
//            int l = 1;
//            while (l < languages.length) {
//                if (languages[l][1] == language) {
//                    relations[languages[l][0] - 1][num - 1] = 1;  //如果两个人掌握了相同的语言，就把关系图中对应的值设为1，表示能够直接交流
//                    relations[num - 1][languages[l][0] - 1] = 1;  //如果两个人掌握了相同的语言，就把关系图中对应的值设为1，表示能够直接交流
//                } else {
//                    num = languages[l][0];
//                    language = languages[l][1];
//                }
//                l++;
//            }
//            int isoNum = findCircleNum(relations);  // 根据关系图去寻找图中能直接交流的人，并且分堆。
//
//            System.out.println(isoNum-1);  //如果最后分为了n堆，那么就只需要n-1台机器就能够满足所有人之间的交流
//        }


//        Scanner in = new Scanner(System.in);
//            int n=4;
//            String str="110011110000011111000111010111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
//            System.out.println(str.length());
//            long time=System.currentTimeMillis();
//            System.out.println(time);
//            System.out.println(lastStrLength(n,str));
//            long time2=System.currentTimeMillis();
//            System.out.println(time2);
//            System.out.println(time2-time);
//
//            int[][]arr={{1,2,3,5},{4,5,6,7},{7,8,9,10},{0,3,2,1}};
//           printMethod(arr);

//
//            int[]arr1 = {2,3,1,3,2,4,6,7,9,2,19};
//            int[]arr2 = {2,1,4,3,9,6};
//            int[]ret=relativeSortArray(arr1,arr2);
//            for(int i=0;i<ret.length;i++){
//                System.out.print(ret[i]+" ");
//            }
    }
}


//    private static Logger logger = Logger.getLogger(Solution.class.getName());
//
//    public static void main(String[] args) {
//
////        int[]arr={1,2,1,1,1};
////        System.out.println(getLongestChildArrInArr(arr,3));
//        int[] arr = {2, 3, 4, 5, 1,6,7,9,8};
//        sortNatureNumber(arr);
//        for (int i = 0; i < arr.length; i++) {
//            System.out.println(arr[i]);
//        }
//
////        int[] arr = {5,1,2,3};
////        System.out.println(reversePairsNumber(arr));
////        String str = "zzzzzzzzzzzzzz";
////        System.out.println(longestNoRepChildStr(str));
////        Node head=new Node(1);
////        int[] arr = {1, 2, 3, 4, 2, 3, 4, 2, 2, 2, 21, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,11,11,1,1,1,1,1,1,1,1,1,1};
////        System.out.println(findOccurTimeSupreOfHalf(arr));
////        int[] arr = {1, 2, 1, 2, 3, 4, 5, 3, 2, 6, 7, 6, 6, 6, 7, 8};
////        int k = findKthSmallNumber(arr, 7);
////        for (int i = 0; i <= k; i++) {
////            System.out.print(arr[i] + " ");
////        }
////        int[] arr = {1, -2, 3, 10, -4, 7, 2, -5};
////        System.out.println(MaxSumOfConsecutiveChildArray(arr));

////        System.out.println(logger);
//    }
//}









































